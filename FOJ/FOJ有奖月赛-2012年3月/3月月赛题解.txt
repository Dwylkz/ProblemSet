A
给一个数列，求i到j之间x出现的次数。用VECTOR存下每个数出现的坐标，或者自己用邻接表存，然后找某个数时二分坐标找。
B
将已经杀死过哪些怪兽用状态压缩表示，比如杀死了第1,3两头，用 101二进制表示，也就是十进制的5，因为最多10头怪，所以最多状态数为2^10。bfs处理出每头怪兽可以到达哪些怪兽，然后处理出每个状态可以到达哪些怪兽，状态转移时就是枚举可达的怪兽。bfs枚举复杂度10*500*500，状态DP复杂度1024*10*10。
C
答案为C(0,n-1)+C(1,n-1)+...+C(n-1,n-1)=2^(n-1)
D
给一个字符串求刚好出现x次的子串，若没有输出没有，有的话输出字典序最小的。后缀数组处理出height[]，然后枚举一遍，维护一个height[]值单调递增的栈，可以得出每个子串出现的次数，从中取最优的。
E
在传统的dancing links解数独问题的基础上，增加26*9行，分别表示26个字母取9个数字的情况。增加9列，表示字母取的数字1-9。

相同字母要取一样的数字，就是把这些字母所影响的列都统一归到该字母的行管理。不同字母要取不一样的数字，就是把每个字母取的数字与新加的1-9列相关联，因为新加的只有1-9列，而且是精确覆盖，所以不同字母取的数字会不一样。但是这样还不够，新加的1-9列可能会有些没被字母用到，比如字母只有两个，不可能用到1-9，所以要再加9行，分别与1-9列想关联，在某些数字没选到时就由这些行选。其实这就是DLX解N皇后问题的方法。
F
将树看成直线，可以看出某些直线是无用的，先预处理排除这些直线，类似凸包，然后剩下的直线在纸上画一下，他们的共同上界是下凹的。对于询问，可以每个询问都二分在那个区间，也就是那条直线上，也可以将询问排序后利用单调性搞。
G
先将这些字符串构造出trie图，然后根据图上的转移建立方程，然后用高斯消元求解。

很多模板题。。上面的很多算法，如果不会，就去学下吧，实在不行就先学会用模板。比如dancinglinks,trie图(AC自动机),后缀数组。还有一些常见的，B题的状态压缩，F题，G题的概率期望列方程求解。