#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <iostream>
#include <vector>
using namespace std;
const int N = 1e5+10;

struct edge_t {
  int v, to, w;
};
vector<edge_t> E;
int L[N];
void init() {
  E.clear();
  memset(L, -1, sizeof(L));
}
void add(int u, int v, int w) {
  edge_t t = {v, L[u], w};
  L[u] = E.size();
  E.push_back(t);
}
struct aca_t {
  static const int n = 100000+10<<4;
  static const int m = 2;
  struct node {
    node *s[m], *p;
  } s[n], *top, *rt, *q[n];
  void init() {
    memset(top = s, 0, sizeof(s));
    rt = top++;
  }
  void put(int k, node *rt) {
    node *x = rt;
    for (int i = 16; i >= 0; i--) {
      if (!x->s[k>>i&1]) x->s[k>>i&1] = top++;
      x = x->s[k>>i&1];
    }
  }
  void tom(int mt[][n]) {
    for (node *x = s; x < top; x++)
      for (int i = 0; i < m; i++)
        if (!x->s[i]->ac) mt[x-s][x->s[i]-s] = 1;
  }
};
namespace seg {
  struct node {
    int l, r;
    aca_t::node *rt; 
    node *ls, *rs;
    int m() {
      return l+r>>1;
    }
  } s[N<<1], *top;
  aca_t aca;
  struct seg_t {
    void init() {
      aca.init();
    }
    void make(int l, int r, node *x = 0) {
      node t = {l, r, 0};
      *x = t;
      if (l == r) return ;
      make(l, x->m(), x->ls = top++);
      make(x->m()+1, r, x->rs = top++);
    }
    void put(int k, int w, node *x) {
      aca.put(w, x->rt);
      if (x->l == x->r) return ;
      int m = x->m();
      if (k <= m) put(k, w, x->ls);
      else put(k, w, x->rs);
    }
    int ask(int l, int r, node *x) {
      if (l <= x->l && x->r <= r) return 0;
      int rv = 0, m = x->m();
      if (l <= m) rv = max(rv, ask(l, r, x->ls));
      if (m < r) rv = max(rv, ask(l, r, x->rs));
      return rv;
    }
  };
}
struct hld_t {
  typedef int ai_t[N];
  int n;
  ai_t d, sz, fa, hv, in, cl, id, w, q;
  void operator () (vector<edge_t> &E, int *L, int V, int u) {
    vector<int> q(1, u);
    n = V;
    d[u] = 0;
    fa[u] = -1;
    for (int h = 0; h < q.size(); h++) {
      u = q[h];
      for (int e = L[u]; ~e; e = E[e].to) {
        int v = E[e].v;
        if (v == fa[u]) continue;
        fa[v] = u;
        d[v] = d[u]+1;
        w[v] = E[e].w;
        q.push_back(v);
      }
    }
    for (int h = q.size()-1; ~h; h--) {
      u = q[h];
      sz[u] = 1;
      hv[u] = -1;
      for (int e = L[u]; ~e; e = E[e].to) {
        int v = E[e].v;
        if (v == fa[u]) continue;
        if (!~hv[u] || sz[v] > sz[hv[u]]) hv[u] = v;
        sz[u] += sz[v];
      }
    }
    q.resize(1);
    in[q[0]] = q[0];
    id[q[0]] = 0;
    cl[q[0]] = 1;
    for (int h = 0; h < q.size(); h++) {
      u = q[h];
      for (int e = L[u]; ~e; e = E[e].to) {
        int v = E[e].v;
        if (v == fa[u]) continue;
        if (v == hv[u]) {
          in[v] = in[u];
          id[v] = id[u]+1;
          cl[in[v]]++;
        } else {
          in[v] = v;
          cl[v] = 1;
          id[v] = 0;
        }
        q.push_back(v);
      }
    }
  }
  seg::node *rt[N];
  seg::seg_t zkl;
  aca_t aca;
  void make() {
    seg::top = seg::s;
    aca.init();
    for (int i = 0; i < n; i++)
      if (in[i] == i) zkl.make(0, cl[i]-1, rt[i] = seg::top++);
    for (int i = 0; i < n; i++) if (in[i] != i) rt[i] = rt[in[i]];
  }
  void put(int v, int w) {
  }
  int ask(int u, int v, int w) {
    if (u == v) return 0;
    int rv = 0;
    for ( ; in[u]^in[v]; u = fa[in[u]]) {
      if (d[in[u]] < d[in[v]]) swap(u, v);
      rv = max(rv, zkl.ask(0, id[u], rt[u]));
    }
    if (id[u] > id[v]) swap(u, v);
    rv = max(rv, zkl.ask(id[u]+1, id[v], rt[u]));
    return rv;
  }
} hld;

int n, m, w[N];

int main() {
#if 1
  freopen("input.in", "r", stdin);
#endif
  for ( ; ~scanf("%d%d", &n, &m); ) {
    init();
    for (int i = 0; i < n-1; i++) {
      int u, v;
      scanf("%d%d", &u, &v);
      u--, v--;
      add(u, v, 0), add(v, u, 0);
    }
    for (int i = 0; i < n; i++) scanf("%d", w+i);
    hld(E, L, n, 0);
    for ( ; m--; ) {
      int u, v, w;
      scanf("%d%d%d", &u, &v, &w);
      u--, v--;
      printf("%d\n", hld.ask(u, v, w));
    }
  }
  return 0;
}
